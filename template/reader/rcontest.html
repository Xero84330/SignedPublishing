{% extends 'reader/rbase.html' %}
{% load static %}
{% block meta %}
<title>Contests | Signed Publishing â€“ Read Stories, Novels, and eBooks</title>
<meta name="description"
  content="Join writing contests on Signed Publishing. Compete, showcase your talent, and win exciting publishing opportunities.">
<meta name="keywords"
  content="writing contests, author competitions, publish your story, online writing, creative contests">
<meta property="og:title" content="Writing Contests | Signed Publishing">
<meta property="og:description"
  content="Showcase your talent and get discovered. Participate in ongoing writing contests on Signed Publishing.">
<meta property="og:url" content="https://www.signedpublishing.com/contest/">
<meta property="og:image" content="{% static 'images/Brown_Full_logo.png' %}">
<meta name="twitter:title" content="Writing Contests | Signed Publishing">
<meta name="twitter:description" content="Join exciting writing contests and stand a chance to get published.">
{% endblock %}
{% block body %}
<section id="contest-section"
  class="relative flex flex-col items-center justify-center min-h-screen bg-orange-50 text-center overflow-hidden select-none">

  <!-- Blurred Background -->
  <div class="absolute inset-0 overflow-hidden pointer-events-none">
    <div class="absolute top-[-6rem] left-1/2 -translate-x-1/2 w-80 h-80 bg-orange-200 rounded-full blur-3xl opacity-40"></div>
    <div class="absolute bottom-[-4rem] right-1/3 w-60 h-60 bg-amber-200 rounded-full blur-2xl opacity-30"></div>
  </div>

  <!-- Title & Subtitle -->
  <h1 id="title"
    class="text-amber-950 font-extrabold text-3xl sm:text-5xl md:text-6xl mb-3 animate-pulse leading-tight transition-opacity duration-300">
    Contest Coming Soon!
  </h1>
  <p id="subtitle" 
    class="text-amber-950 text-base sm:text-lg md:text-xl mb-10 transition-opacity duration-300">
    Get ready for exciting challenges and prizes!
  </p>

  <!-- PADDLE BUTTON -->
  <button id="paddle"
    class="absolute bg-amber-900 text-white px-6 py-3 rounded-3xl text-sm sm:text-base font-bold hover:bg-orange-500 transition-all duration-300 cursor-grab active:cursor-grabbing z-20 shadow-lg"
    style="left: 50%; transform: translateX(-50%); bottom: 120px;">
    Stay Tuned
  </button>

  <!-- BRICKS -->
  <div id="brick-container" class="absolute inset-0 hidden pointer-events-none z-10"></div>

  <!-- CANVAS -->
  <canvas id="gameCanvas" class="hidden absolute inset-0 w-full h-full z-5"></canvas>

  <!-- EXIT -->
  <button id="exitGame"
    class="hidden absolute top-4 right-4 bg-white text-amber-900 font-bold px-3 py-2 rounded-xl shadow-md z-30">
    Exit
  </button>

  <!-- GAME OVER -->
  <div id="gameOverUI"
    class="hidden absolute inset-0 bg-black/60 flex flex-col justify-center items-center text-white gap-4 backdrop-blur-md z-40">
    <p class="text-2xl font-bold">Game Over</p>
    <button id="playAgain" class="bg-orange-500 text-white rounded-xl px-6 py-3 font-bold text-lg">Play Again</button>
    <button id="exit2" class="bg-white text-orange-600 px-6 py-3 rounded-xl font-bold text-lg">Exit</button>
  </div>
</section>

<script>
  const section = document.getElementById("contest-section");
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const paddle = document.getElementById("paddle");
  const exitGame = document.getElementById("exitGame");
  const gameOverUI = document.getElementById("gameOverUI");
  const brickContainer = document.getElementById("brick-container");
  const titleEl = document.getElementById("title");
  const subtitleEl = document.getElementById("subtitle");

  let canvasW, canvasH;
  let gameRunning = false;
  let lastTime = 0;
  let animationFrameId = null; // To store the requestAnimationFrame ID
  let bricks = [];

  const baseSpeed = 320; // pixels per second
  const ball = { x: 0, y: 0, vx: 0, vy: 0, r: 9 };
  let paddleX = 0; // Paddle's x-position, relative to canvas

  // === Resize Canvas and Paddle Position ===
  function resize() {
    canvasW = section.clientWidth;
    canvasH = section.clientHeight;
    canvas.width = canvasW;
    canvas.height = canvasH;

    // Adjust paddle's bottom position based on screen size
    const isMobile = window.innerWidth <= 768;
    const bottomOffset = isMobile ? Math.min(canvasH * 0.20, 110) : Math.min(canvasH * 0.15, 120);
    paddle.style.bottom = `${bottomOffset}px`;

    // Ensure paddle is centered on resize if game not running
    if (!gameRunning) {
      paddleX = (canvasW - paddle.offsetWidth) / 2;
      paddle.style.left = `${paddleX}px`;
      paddle.style.transform = "none"; // Remove transform for consistent positioning
    }
  }

  resize(); // Initial resize
  window.addEventListener("resize", resize);

  // === Bricks ===
  function buildBricks() {
    brickContainer.innerHTML = "";
    bricks = [];
    const text = "CONTEST COMING SOON";
    const wrap = document.createElement("div");
    wrap.style.cssText = `
      position: absolute; left: 50%; top: 12%;
      transform: translateX(-50%);
      display: flex; flex-wrap: wrap;
      gap: 8px; justify-content: center;
      font-size: clamp(1rem, 3.5vw, 2rem);
      line-height: 1.1; pointer-events: none;
    `;
    brickContainer.appendChild(wrap);

    [...text].forEach(ch => {
      if (ch === " ") {
        const s = document.createElement("div");
        s.style.width = "16px";
        wrap.appendChild(s);
        return;
      }
      const el = document.createElement("div");
      el.textContent = ch;
      el.style.cssText = `
        font-weight: 900;
        color: #92400E;
        background: rgba(253,186,116,0.3);
        border-radius: 8px;
        padding: 4px 8px;
        transition: all 0.3s ease;
        user-select: none;
      `;
      wrap.appendChild(el);
      // Store brick element and its hit status
      bricks.push({ el, hit: false });
    });
  }

  // === Start Game ===
  function startGame() {
    if (gameRunning) return; // Prevent multiple starts

    titleEl.style.opacity = "0";
    subtitleEl.style.opacity = "0";
    brickContainer.classList.remove("hidden");
    canvas.classList.remove("hidden");
    exitGame.classList.remove("hidden");
    gameOverUI.classList.add("hidden"); // Hide game over UI if visible

    // Position paddle for game (transition only if not already in game mode)
    if (paddle.style.transition === "") {
        paddle.style.transition = "bottom 0.6s ease, left 0.1s linear"; // Add left transition
    }

    buildBricks();

    // Initial ball position
    ball.x = canvasW / 2;
    ball.y = canvasH * 0.6;
    const angle = Math.PI / 4 + Math.random() * Math.PI / 4; // Random angle between 45 and 90 degrees
    ball.vx = Math.cos(angle) * baseSpeed * (Math.random() < 0.5 ? 1 : -1); // Random initial horizontal direction
    ball.vy = -Math.abs(Math.sin(angle) * baseSpeed); // Always move up initially

    gameRunning = true;
    lastTime = performance.now();
    animationFrameId = requestAnimationFrame(loop);
  }

  // === Brick Collisions ===
  function checkBricks() {
    const sectionRect = section.getBoundingClientRect(); // Get section rect once
    bricks.forEach(b => {
      if (b.hit) return; // Skip already hit bricks

      const r = b.el.getBoundingClientRect(); // Get brick's current position
      const bx = r.left - sectionRect.left;
      const by = r.top - sectionRect.top;
      const bw = r.width;
      const bh = r.height;

      // Simple AABB collision detection
      if (ball.x + ball.r > bx && ball.x - ball.r < bx + bw &&
          ball.y + ball.r > by && ball.y - ball.r < by + bh) {
        b.hit = true;
        b.el.style.opacity = "0";
        b.el.style.transform = "scale(0.5) rotate(15deg)";

        // Reverse vertical velocity
        ball.vy *= -1.05; // Increase speed slightly
        
        // Optional: Check if all bricks are hit
        if (bricks.every(b => b.hit)) {
            endGame(true); // Player won!
        }
      }
    });
  }

  // === Game Loop ===
  function loop(now) {
    if (!gameRunning) {
        cancelAnimationFrame(animationFrameId);
        return;
    }

    let dt = (now - lastTime) / 1000;
    // Cap delta time to prevent physics anomalies on very slow frames
    if (dt > 0.05) dt = 0.05; 
    lastTime = now;

    // Update ball position
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // Wall collision
    if (ball.x - ball.r < 0) {
      ball.x = ball.r;
      ball.vx *= -1;
    } else if (ball.x + ball.r > canvasW) {
      ball.x = canvasW - ball.r;
      ball.vx *= -1;
    }

    if (ball.y - ball.r < 0) {
      ball.y = ball.r;
      ball.vy *= -1;
    }

    // Paddle collision
    // Get paddle's current bounding box relative to the canvas
    const pRect = paddle.getBoundingClientRect();
    const sRect = section.getBoundingClientRect(); // Section's bounding box
    const paddleLeft = pRect.left - sRect.left; // Paddle's left edge relative to section
    const paddleTop = pRect.top - sRect.top; // Paddle's top edge relative to section
    const paddleWidth = pRect.width;
    const paddleHeight = pRect.height;

    // Check if ball hits paddle
    if (ball.x > paddleLeft && ball.x < paddleLeft + paddleWidth &&
        ball.y + ball.r > paddleTop && ball.y - ball.r < paddleTop + paddleHeight) {
      
      // Calculate where on the paddle the ball hit (normalized -1 to 1)
      const hitPoint = (ball.x - (paddleLeft + paddleWidth / 2)) / (paddleWidth / 2);
      const speed = Math.hypot(ball.vx, ball.vy); // Current ball speed

      // Calculate new angle based on hit point
      const maxBounceAngle = Math.PI / 2.5; // Max 72 degrees for horizontal bounce
      const newAngle = hitPoint * maxBounceAngle;

      ball.vx = speed * Math.sin(newAngle);
      ball.vy = -Math.abs(speed * Math.cos(newAngle)); // Always bounce upwards

      // Move ball out of paddle to prevent sticking
      ball.y = paddleTop - ball.r;
    }

    checkBricks();

    // Clear canvas
    ctx.clearRect(0, 0, canvasW, canvasH);

    // Draw ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = "#9A3412";
    ctx.fill();

    // Game over condition
    if (ball.y - ball.r > canvasH) {
      endGame(false); // Player lost
      return; // Stop the current frame
    }
    
    animationFrameId = requestAnimationFrame(loop);
  }

  // === End Game ===
  function endGame(won) {
    gameRunning = false;
    cancelAnimationFrame(animationFrameId); // Stop the game loop

    // Show Game Over UI
    gameOverUI.classList.remove("hidden");
    if (won) {
        gameOverUI.querySelector('p').textContent = "You Won!";
    } else {
        gameOverUI.querySelector('p').textContent = "Game Over";
    }

    // Restore paddle's initial state (optional, can be done on reload too)
    paddle.style.transition = "bottom 0.6s ease, left 0.1s linear";
    paddle.style.bottom = "120px";
    paddle.style.left = "50%";
    paddle.style.transform = "translateX(-50%)";

    // Hide game elements
    canvas.classList.add("hidden");
    brickContainer.classList.add("hidden");
    exitGame.classList.add("hidden");
  }


  // === Paddle Movement (mouse + touch) ===
  let isDragging = false;
  let paddleDragOffset = 0; // Offset from mouse/touch to paddle's center

  function movePaddle(clientX) {
    const sectionRect = section.getBoundingClientRect();
    const paddleRect = paddle.getBoundingClientRect();

    // Calculate mouse/touch position relative to the section
    const mouseX = clientX - sectionRect.left;

    // Calculate new paddleX position
    let newPaddleX = mouseX - paddleDragOffset;

    // Clamp paddleX within canvas bounds
    newPaddleX = Math.max(0, Math.min(newPaddleX, canvasW - paddleRect.width));
    paddleX = newPaddleX; // Update the internal paddleX

    // Apply new position to CSS
    paddle.style.left = `${paddleX}px`;
    paddle.style.transform = "none"; // Ensure transform doesn't interfere
  }

  // Mouse Events
  section.addEventListener("mousedown", e => {
    if (!gameRunning) return; // Only allow paddle interaction during game
    const paddleRect = paddle.getBoundingClientRect();
    const sectionRect = section.getBoundingClientRect();
    const paddleLeft = paddleRect.left - sectionRect.left;

    if (e.target === paddle) {
      isDragging = true;
      paddleDragOffset = e.clientX - paddleRect.left; // Distance from mouse to paddle's left edge
      movePaddle(e.clientX);
    }
  });

  section.addEventListener("mousemove", e => {
    if (isDragging) {
      movePaddle(e.clientX);
    }
  });

  section.addEventListener("mouseup", () => {
    isDragging = false;
  });

  // Touch Events (passive: false for preventDefault)
  section.addEventListener("touchstart", e => {
    if (!gameRunning) return; // Only allow paddle interaction during game
    const paddleRect = paddle.getBoundingClientRect();
    const sectionRect = section.getBoundingClientRect();
    const paddleLeft = paddleRect.left - sectionRect.left;

    if (e.touches.length === 1) {
      isDragging = true;
      paddleDragOffset = e.touches[0].clientX - paddleRect.left;
      movePaddle(e.touches[0].clientX);
      e.preventDefault(); // Prevent scrolling
    }
  }, { passive: false });

  section.addEventListener("touchmove", e => {
    if (isDragging && e.touches.length === 1) {
      movePaddle(e.touches[0].clientX);
      e.preventDefault(); // Prevent scrolling
    }
  }, { passive: false });

  section.addEventListener("touchend", () => {
    isDragging = false;
  });

  // === Buttons ===
  paddle.addEventListener("click", (e) => {
    e.preventDefault(); // Prevent default button behavior
    if (!gameRunning) {
      startGame();
    }
  });

  exitGame.onclick = () => location.reload();
  playAgain.onclick = () => startGame(); // Restart game directly
  exit2.onclick = () => location.reload(); // Reload to initial state
</script>
{% endblock %}